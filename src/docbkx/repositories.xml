<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="repositories">
  <title>Working with Spring Data Repositories</title>

  <para>The goal of Spring Data repository abstraction is to significantly
  reduce the amount of boilerplate code required to implement data access
  layers for various persistence stores.</para>

  <important>
    <para><emphasis>Spring Data repository documentation and your
    module</emphasis></para>

    <para>This chapter explains the core concepts and interfaces of Spring
    Data repositories. The information in this chapter is pulled from the
    Spring Data Commons module. It uses the configuration and code samples for
    the Java Persistence API (JPA) module. Adapt the XML namespace declaration
    and the types to be extended to the equivalents of the particular module
    that you are using. <xref linkend="namespace-reference"/> covers XML
    configuration which is supported across all Spring Data modules supporting
    the repository API, <xref linkend="repository-query-keywords"/> covers the
    query method method keywords supported by the repository abstraction in
    general. For detailed information on the specific features of your module,
    consult the chapter on that module of this document.</para>
  </important>

  <section id="repositories.core-concepts">
    <title>Core concepts</title>

    <para>The central interface in Spring Data repository abstraction is
    <interfacename>Repository</interfacename> (probably not that much of a
    surprise). It takes the the domain class to manage as well as the id type
    of the domain class as type arguments. This interface acts primarily as a
    marker interface to capture the types to work with and to help you to
    discover interfaces that extend this one. The
    <interfacename>CrudRepository</interfacename> provides sophisticated CRUD
    functionality for the entity class that is being managed.</para>

    <example id="repositories.repository">
      <title><interfacename>CrudRepository</interfacename> interface</title>

      <programlistingco>
        <areaspec>
          <area coords="3" id="repository.save"/>

          <area coords="5" id="repository.find-by-id"/>

          <area coords="7" id="repository.find-all"/>

          <area coords="11" id="repository.count"/>

          <area coords="13" id="repository.delete"/>

          <area coords="15" id="repository.exists"/>
        </areaspec>

        <programlisting language="java">public interface CrudRepository&lt;T, ID extends Serializable&gt;
    extends Repository&lt;T, ID&gt; {

    &lt;S extends T&gt; S save(S entity);

    T findOne(ID primaryKey);

    Iterable&lt;T&gt; findAll();

    Long count();

    void delete(T entity);

    boolean exists(ID primaryKey);

    // … more functionality omitted.
}</programlisting>

        <calloutlist>
          <callout arearefs="repository.save">
            <para>Saves the given entity.</para>
          </callout>

          <callout arch="" arearefs="repository.find-by-id">
            <para>Returns the entity identified by the given id.</para>
          </callout>

          <callout arearefs="repository.find-all">
            <para>Returns all entities.</para>
          </callout>

          <callout arearefs="repository.count">
            <para>Returns the number of entities.</para>
          </callout>

          <callout arearefs="repository.delete">
            <para>Deletes the given entity.</para>
          </callout>

          <callout arearefs="repository.exists">
            <para>Indicates whether an entity with the given id exists.</para>
          </callout>
        </calloutlist>
      </programlistingco>
    </example>

    <para>Usually we will have persistence technology specific sub-interfaces
    to include additional technology specific methods. We will now ship
    implementations for a variety of Spring Data modules that implement
    <interfacename>CrudRepository</interfacename>.</para>

    <!--OG: Reverted to old wording as it made more sense. Refer to CrudRepository to be more specific. Discuss what
exactly is hardly understandable with the current wording.-->

    <para>On top of the <interfacename>CrudRepository</interfacename> there is
    a <interfacename>PagingAndSortingRepository</interfacename> abstraction
    that adds additional methods to ease paginated access to entities:</para>

    <example>
      <title>PagingAndSortingRepository</title>

      <programlisting language="java">public interface PagingAndSortingRepository&lt;T, ID extends Serializable&gt; 
  extends CrudRepository&lt;T, ID&gt; {

  Iterable&lt;T&gt; findAll(Sort sort);

  Page&lt;T&gt; findAll(Pageable pageable);
}</programlisting>
    </example>

    <para>Accessing the second page of <classname>User</classname> by a page
    size of 20 you could simply do something like this:</para>

    <programlisting language="java">PagingAndSortingRepository&lt;User, Long&gt; repository = // … get access to a bean
Page&lt;User&gt; users = repository.findAll(new PageRequest(1, 20));</programlisting>
  </section>

  <section id="repositories.query-methods">
    <title>Query methods</title>

    <para>Standard CRUD functionality repositories usually have queries on the
    underlying datastore. With Spring Data, declaring those queries becomes a
    four-step process:</para>

    <orderedlist>
      <listitem>
        <para>Declare an interface extending
        <interfacename>Repository</interfacename> or one of its subinterfaces
        and type it to the domain class that it will handle.</para>

        <programlisting language="java">public interface PersonRepository extends Repository&lt;User, Long&gt; { … }</programlisting>
      </listitem>

      <listitem>
        <para>Declare query methods on the interface.</para>

        <programlisting language="java">List&lt;Person&gt; findByLastname(String lastname);</programlisting>
      </listitem>

      <listitem>
        <para>Set up Spring to create proxy instances for those
        interfaces.</para>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans:beans xmlns:beans="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns="http://www.springframework.org/schema/data/jpa"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/jpa
    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;

  &lt;repositories base-package="com.acme.repositories" /&gt;

&lt;/beans&gt;</programlisting>

        <note>
          <para>The JPA namespace is used in this example. If you are using
          the repository abstraction for any other store, you need to change
          this to the appropriate namespace declaration of your store module
          which should be exchanging <code>jpa</code> in favor of, for
          example, <code>mongodb</code>.</para>
        </note>
      </listitem>

      <listitem>
        <para>Get the repository instance injected and use it.</para>

        <programlisting language="java">public class SomeClient {

  @Autowired
  private PersonRepository repository;

  public void doSomething() {
    List&lt;Person&gt; persons = repository.findByLastname("Matthews");
  }
}</programlisting>
      </listitem>
    </orderedlist>

    <para>The sections that follow explain each step.</para>

    <section id="repositories.definition">
      <title>Defining repository interfaces</title>

      <para>As a first step you define a domain class-specific repository
      interface. The interface must extend
      <interfacename>Repository</interfacename> and be typed to the domain
      class and an ID type. If you want to expose CRUD methods for that domain
      type, extend <interfacename>CrudRepository</interfacename> instead of
      <interfacename>Repository</interfacename>.</para>

      <section id="repositories.definition-tuning">
        <title>Fine-tuning repository definition</title>

        <para>Typically, your repository interface will extend
        <interfacename>Repository</interfacename>,
        <interfacename>CrudRepository</interfacename> or
        <interfacename>PagingAndSortingRepository</interfacename>.
        Alternatively, if you do not want to extend Spring Data interfaces,
        you can also annotate your repository interface with
        <interfacename>@RepositoryDefinition</interfacename>.<!--BT Preceding, where is an example of annotating with @RepositoryDefinition? If preceding is an alternative to 
what you do in first sentence, I would move it after the info about extending Repository, CrudRep, etc.

OG I'd like to keep it at this point as we're discussing here what is needed to let an interface be discovered 
as Spring Data repository. Beyond that, there's not much more to tell about the annotation, so that mentioning
it later on would create a high noise/effect ratio. What do you think?-->
        Extending <interfacename>CrudRepository</interfacename> exposes a
        complete set of methods to manipulate your entities. If you prefer to
        be selective about the methods being exposed, simply copy the ones you
        want to expose from <interfacename>CrudRepository</interfacename> into
        your domain repository.</para>

        <example>
          <title>Selectively exposing CRUD methods</title>

          <programlisting language="java">interface MyBaseRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; {
  T findOne(ID id);
  T save(T entity);
}

interface UserRepository extends MyBaseRepository&lt;User, Long&gt; {

  User findByEmailAddress(EmailAddress emailAddress);
}</programlisting>
        </example>

        <para>In this first step you defined a common base interface for all
        your domain repositories and exposed
        <methodname>findOne(…)</methodname> as well as
        <methodname>save(…)</methodname>.These methods will be routed into the
        base repository implementation of the store of your choice provided by
        Spring Data because they are matching the method signatures in
        <interfacename>CrudRepository</interfacename>. So the
        <interfacename>UserRepository</interfacename> will now be able to save
        users, and find single ones by id, as well as triggering a query to
        find <interfacename>User</interfacename>s by their email
        address.</para>
      </section>
    </section>

    <section id="repositories.query-methods.details">
      <title>Defining query methods</title>

      <para>The repository proxy has two ways to derive a store-specific query
      from the method name. It can derive the query from the method name
      directly, or by using an additionally created query. Available options
      depend on the actual store. However, there's got to be an strategy that
      decides what actual query is created. Let's have a look at the available
      options.</para>

      <section id="repositories.query-methods.query-lookup-strategies">
        <title>Query lookup strategies</title>

        <para>The following strategies are available for the repository
        infrastructure to resolve the query. You can configure the strategy at
        the namespace through the <code>query-lookup-strategy</code>
        attribute. Some strategies may not be supported for particular
        datastores.</para>

        <simplesect>
          <title>CREATE</title>

          <para><code>CREATE</code> attempts to construct a store-specific
          query from the query method name. The general approach is to remove
          a given set of well-known prefixes from the method name and parse
          the rest of the method. Read more about query construction in <xref
          linkend="repositories.query-methods.query-creation"/>.</para>
        </simplesect>

        <simplesect>
          <title>USE_DECLARED_QUERY</title>

          <para><code>USE_DECLARED_QUERY</code> tries to find a declared query
          and will throw an exception in case it can't find one. The query can
          be defined by an annotation somewhere or declared by other means.
          Consult the documentation of the specific store to find available
          options for that store. If the repository infrastructure does not
          find a declared query for the method at bootstrap time, it
          fails.</para>
        </simplesect>

        <simplesect>
          <title>CREATE_IF_NOT_FOUND (default)</title>

          <para><code>CREATE_IF_NOT_FOUND</code> combines <code>CREATE</code>
          and <code>USE_DECLARED_QUERY</code>. It looks up a declared query
          first, and if no declared query is found, it creates a custom method
          name-based query. This is the default lookup strategy and thus will
          be used if you do not configure anything explicitly. It allows quick
          query definition by method names but also custom-tuning of these
          queries by introducing declared queries as needed.</para>
        </simplesect>
      </section>

      <section id="repositories.query-methods.query-creation">
        <title>Query creation</title>

        <para>The query builder mechanism built into Spring Data repository
        infrastructure is useful for building constraining queries over
        entities of the repository. The mechanism strips the prefixes
        <code>find…By</code>, <code>read…By</code>, and <code>get…By</code>
        from the method and starts parsing the rest of it. The introducing
        clause can contain further expressions such as a <code>Distinct</code>
        to set a distinct flag on the query to be created. However, the first
        <code>By</code> acts as delimiter to indicate the start of the actual
        criteria. At a very basic level you can define conditions on entity
        properties and concatenate them with <code>And</code> and <code>Or
        </code>.</para>

        <example>
          <title>Query creation from method names</title>

          <para><programlisting language="java">public interface PersonRepository extends Repository&lt;User, Long&gt; {

  List&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);

  // Enables the distinct flag for the query
  List&lt;Person&gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
  List&lt;Person&gt; findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);

  // Enabling ignoring case for an individual property
  List&lt;Person&gt; findByLastnameIgnoreCase(String lastname);
  // Enabling ignoring case for all suitable properties
  List&lt;Person&gt; findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);

  // Enabling static ORDER BY for a query
  List&lt;Person&gt; findByLastnameOrderByFirstnameAsc(String lastname);
  List&lt;Person&gt; findByLastnameOrderByFirstnameDesc(String lastname);
}</programlisting></para>
        </example>

        <para>The actual result of parsing the method depends on the
        persistence store for which you create the query. However, there are
        some general things to notice. <itemizedlist>
            <listitem>
              <para>The expressions are usually property traversals combined
              with operators that can be concatenated. You can combine
              property expressions with <code>AND</code> and <code>OR</code>.
              You also get support for operators such as
              <literal>Between</literal>, <literal>LessThan</literal>,
              <literal>GreaterThan</literal>, <literal>Like</literal> for the
              property expressions. The supported operators can vary by
              datastore, so consult the appropriate part of your reference
              documentation.</para>
            </listitem>

            <listitem>
              <para>The method parser supports setting an
              <code>IgnoreCase</code> flag for individual properties, for
              example,<methodname>findByLastnameIgnoreCase(…)</methodname>) or
              for all properties of a type that support ignoring case (usually
              <code>String</code>s, for example,
              <methodname>findByLastnameAndFirstnameAllIgnoreCase(…)</methodname>).
              Whether ignoring cases is supported may vary by store, so
              consult the relevant sections in the reference documentation for
              the store-specific query method.</para>
            </listitem>

            <listitem>
              <para>You can apply static ordering by appending an
              <code>OrderBy</code> clause to the query method that references
              a property and by providing a sorting direction
              (<code>Asc</code> or <code>Desc</code>). To create a query
              method that supports dynamic sorting, see <xref
              linkend="repositories.special-parameters"/>.</para>
            </listitem>
          </itemizedlist></para>
      </section>

      <section>
        <title>Property expressions</title>

        <para>Property expressions can refer only to a direct property of the
        managed entity, as shown in the preceding example. At query creation
        time you already make sure that the parsed property is a property of
        the managed domain class. However, you can also define constraints by
        traversing nested properties. Assume <classname>Person</classname>s
        have <classname>Address</classname>es with
        <classname>ZipCode</classname>s. In that case a method name of</para>

        <programlisting language="java">List&lt;Person&gt; findByAddressZipCode(ZipCode zipCode);</programlisting>

        <para>creates the property traversal <code>x.address.zipCode</code>.
        The resolution algorithm starts with interpreting the entire part
        (<literal>AddressZipCode</literal>) as the property and checks the
        domain class for a property with that name (uncapitalized). If the
        algorithm succeeds it uses that property. If not, the algorithm splits
        up the source at the camel case parts from the right side into a head
        and a tail and tries to find the corresponding property, in our
        example, <literal>AddressZip</literal> and <literal>Code</literal>. If
        the algorithm finds a property with that head it takes the tail and
        continue building the tree down from there, splitting the tail up in
        the way just described. If the first split does not match, the
        algorithm move the split point to the left
        (<literal>Address</literal>, <literal>ZipCode</literal>) and
        continues.</para>

        <para>Although this should work for most cases, it is possible for the
        algorithm to select the wrong property. Suppose the
        <classname>Person</classname> class has an <code>addressZip</code>
        property as well. The algorithm would match in the first split round
        already<!--BT why would it match? the first split capitalizes Address.

OG No, as described above the first split results in "AddressZip" and "Code" as first step and would thus match
the just introduced theoretical property.--> and essentially choose the wrong
        property and finally fail (as the type of
        <classname>addressZip</classname> probably has no code property). <!--BT why would it choose the wrong property if it matches? Does this paragraph need clarification?

OG Does that make sense with my comment above?-->To resolve this ambiguity you
        can use <literal>_</literal> inside your method name to manually
        define traversal points. So our method name would end up like
        so:</para>

        <programlisting language="java">List&lt;Person&gt; findByAddress_ZipCode(ZipCode zipCode);
</programlisting>
      </section>

      <section id="repositories.special-parameters">
        <title>Special parameter handling</title>

        <para>To handle parameters to your query you simply define method
        parameters as already seen in the examples above. Besides that the
        infrastructure will recognize certain specific types like
        <interfacename>Pageable</interfacename> and
        <classname>Sort</classname> to apply pagination and sorting to your
        queries dynamically.</para>

        <example>
          <title>Using Pageable and Sort in query methods</title>

          <programlisting>Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);

List&lt;User&gt; findByLastname(String lastname, Sort sort);

List&lt;User&gt; findByLastname(String lastname, Pageable pageable);</programlisting>
        </example>

        <para>The first method allows you to pass an
        <code>org.springframework.data.domain.Pageable</code> instance to the
        query method to dynamically add paging to your statically defined
        query. Sorting options are handled through the
        <interfacename>Pageable</interfacename> instance too. If you only need
        sorting, simply add an
        <code>org.springframework.data.domain.Sort</code> parameter to your
        method. As you also can see, simply returning a
        <interfacename>List</interfacename> is possible as well. In this case
        the additional metadata required to build the actual
        <interfacename>Page</interfacename> instance will not be created
        (which in turn means that the additional count query that would have
        been necessary not being issued) but rather simply restricts the query
        to look up only the given range of entities.</para>

        <note>
          <para>To find out how many pages you get for a query entirely you
          have to trigger an additional count query. By default this query
          will be derived from the query you actually trigger.</para>
        </note>
      </section>
    </section>

    <section id="repositories.create-instances">
      <title>Creating repository instances</title>

      <para>In this section you create instances and bean definitions for the
      repository interfaces defined. The easiest way to do so is by using the
      Spring namespace that is shipped with each Spring Data module that
      supports the repository mechanism.</para>

      <section id="repositories.create-instances.spring">
        <title>XML configuration</title>

        <para>Each Spring Data module includes a repositories element that
        allows you to simply define a base package that Spring scans for
        you.</para>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans:beans xmlns:beans="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns="http://www.springframework.org/schema/data/jpa"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/jpa
    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;

  &lt;repositories base-package="com.acme.repositories" /&gt;

&lt;/beans:beans&gt;</programlisting>

        <para>In the preceding example, Spring is instructed to scan
        <package>com.acme.repositories</package> and all its subpackages for
        interfaces extending <interfacename>Repository</interfacename> or one
        of its subinterfaces. For each interface found, the infrastructure
        registers the persistence technology-specific
        <interfacename>FactoryBean</interfacename> to create the appropriate
        proxies that handle invocations of the query methods. Each bean is
        registered under a bean name that is derived from the interface name,
        so an interface of <interfacename>UserRepository</interfacename> would
        be registered under <code>userRepository</code>. The
        <code>base-package</code> attribute allows wildcards, so that you can
        have a pattern of scanned packages.</para>

        <simplesect>
          <title>Using filters</title>

          <para>By default the infrastructure picks up every interface
          extending the persistence technology-specific
          <interfacename>Repository</interfacename> subinterface located under
          the configured base package and creates a bean instance for it.
          However, you might want more fine-grained control over which
          interfaces bean instances get created for. To do this you use
          <code>&lt;include-filter /&gt;</code> and <code>&lt;exclude-filter
          /&gt;</code> elements inside <code>&lt;repositories /&gt;</code>.
          The semantics are exactly equivalent to the elements in Spring's
          context namespace. For details, see <ulink
          url="http://static.springsource.org/spring/docs/2.5.x/reference/beans.html#beans-scanning-filters"
          vendor="">Spring reference documentation</ulink> on these
          elements.</para>

          <para>For example, to exclude certain interfaces from instantiation
          as repository, you could use the following configuration:</para>

          <example>
            <title>Using exclude-filter element</title>

            <programlisting language="xml">&lt;repositories base-package="com.acme.repositories"&gt;
  &lt;context:exclude-filter type="regex" expression=".*SomeRepository" /&gt;
&lt;/repositories&gt;</programlisting>

            <para>This example excludes all interfaces ending in
            <interfacename>SomeRepository</interfacename> from being
            instantiated.</para>
          </example>
        </simplesect>
      </section>

      <section id="repositories.create-instances.java-config">
        <title>JavaConfig</title>

        <para>The repository infrastructure can also be triggered using a
        store-specific
        <interfacename>@Enable${store}Repositories</interfacename> annotation
        on a JavaConfig class. For an introduction into Java-based
        configuration of the Spring container, see the reference
        documentation.<footnote>
            <para>JavaConfig in the Spring reference documentation - <ulink
            url="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/beans.html#beans-java"/></para>
          </footnote></para>

        <para>A sample configuration to enable Spring Data repositories looks
        something like this.</para>

        <example>
          <title>Sample annotation based repository configuration</title>

          <programlisting>@Configuration
@EnableJpaRepositories("com.acme.repositories")
class ApplicationConfiguration {

  @Bean
  public EntityManagerFactory entityManagerFactory() {
    // …
  }
}</programlisting>
        </example>

        <note>
          <para>The sample uses the JPA-specific annotation, which you would
          change according to the store module you actually use. The same
          applies to the definition of the
          <interfacename>EntityManagerFactory</interfacename> bean. Consult
          the sections covering the store-specific configuration.</para>
        </note>
      </section>

      <section id="repositories.create-instances.standalone">
        <title>Standalone usage</title>

        <para>You can also use the repository infrastructure outside of a
        Spring container. You still need some Spring libraries in your
        classpath, but generally you can set up repositories programmatically
        as well. The Spring Data modules that provide repository support ship
        a persistence technology-specific
        <classname>RepositoryFactory</classname> that you can use as
        follows.</para>

        <example>
          <title>Standalone usage of repository factory</title>

          <programlisting language="java">RepositoryFactorySupport factory = … // Instantiate factory here
UserRepository repository = factory.getRepository(UserRepository.class);</programlisting>
        </example>
      </section>
    </section>
  </section>

  <section id="repositories.custom-implementations">
    <title>Custom implementations for Spring Data repositories</title>

    <para>Often it is necessary to provide a custom implementation for a few
    repository methods. Spring Data repositories easily allow you to provide
    custom repository code and integrate it with generic CRUD abstraction and
    query method functionality.</para>

    <section id="repositories.single-repository-behaviour">
      <title>Adding custom behavior to single repositories</title>

      <para>To enrich a repository with custom functionality you first define
      an interface and an implementation for the custom functionality. Use the
      repository interface you provided to extend the custom interface.</para>

      <example>
        <title>Interface for custom repository functionality</title>

        <programlisting language="java">interface UserRepositoryCustom {

  public void someCustomMethod(User user);
}</programlisting>
      </example>

      <example>
        <title>Implementation of custom repository functionality</title>

        <para><programlisting language="java">class UserRepositoryImpl implements UserRepositoryCustom {

  public void someCustomMethod(User user) {
    // Your custom implementation
  }
}</programlisting><note>
            <para>The implementation itself does not depend on Spring Data and
            can be a regular Spring bean. So you can use standard dependency
            injection behavior to inject references to other beans, take part
            in aspects, and so on.</para>
          </note></para>
      </example>

      <example>
        <title>Changes to the your basic repository interface</title>

        <para><programlisting language="java">public interface UserRepository extends CrudRepository&lt;User, Long&gt;, UserRepositoryCustom {

  // Declare query methods here
}</programlisting>Let your standard repository interface extend the custom
        one. Doing so makes CRUD and custom functionality available to
        clients.</para>
      </example>

      <simplesect>
        <title>Configuration</title>

        <para>If you use namespace configuration, the repository
        infrastructure tries to autodetect custom implementations by scanning
        for classes below the package we found a repository in. These classes
        need to follow the naming convention of appending the namespace
        element's attribute <code>repository-impl-postfix</code> to the found
        repository interface name. This postfix defaults to
        <code>Impl</code>.</para>

        <example>
          <title>Configuration example</title>

          <para><programlisting language="xml">&lt;repositories base-package="com.acme.repository" /&gt;

&lt;repositories base-package="com.acme.repository" repository-impl-postfix="FooBar" /&gt;</programlisting></para>
        </example>

        <para>The first configuration example will try to look up a class
        <classname>com.acme.repository.UserRepositoryImpl</classname> to act
        as custom repository implementation, where the second example will try
        to lookup
        <classname>com.acme.repository.UserRepositoryFooBar</classname>.</para>
      </simplesect>

      <simplesect>
        <title>Manual wiring</title>

        <para>The preceding approach works well if your custom implementation
        uses annotation-based configuration and autowiring only, as it will be
        treated as any other Spring bean. If your custom implementation bean
        needs special wiring, you simply declare the bean and name it after
        the conventions just described. The infrastructure will then refer to
        the manually defined bean definition by name instead of creating one
        itself.</para>

        <example>
          <title>Manual wiring of custom implementations (I)</title>

          <programlisting language="xml">&lt;repositories base-package="com.acme.repository" /&gt;

&lt;beans:bean id="userRepositoryImpl" class="…"&gt;
  &lt;!-- further configuration --&gt;
&lt;/beans:bean&gt;</programlisting>
        </example>
      </simplesect>
    </section>

    <section id="repositories.custom-behaviour-for-all-repositories">
      <title>Adding custom behavior to all repositories</title>

      <para>The preceding approach is not feasible when you want to add a
      single method to all your repository interfaces.</para>

      <orderedlist>
        <listitem>
          <para>To add custom behavior to all repositories, you first add an
          intermediate interface to declare the shared behavior.</para>

          <example>
            <title>An interface declaring custom shared behavior</title>

            <para><programlisting language="java">
public interface MyRepository&lt;T, ID extends Serializable&gt;
  extends JpaRepository&lt;T, ID&gt; {

  void sharedCustomMethod(ID id);
}</programlisting></para>
          </example>

          <para>Now your individual repository interfaces will extend this
          intermediate interface instead of the
          <interfacename>Repository</interfacename> interface to include the
          functionality declared.</para>
        </listitem>

        <listitem>
          <para>Next, create an implementation of the intermediate interface
          that extends the persistence technology-specific repository base
          class. This class will then act as a custom base class for the
          repository proxies.</para>

          <example>
            <title>Custom repository base class</title>

            <programlisting language="java">
public class MyRepositoryImpl&lt;T, ID extends Serializable&gt;
  extends SimpleJpaRepository&lt;T, ID&gt; implements MyRepository&lt;T, ID&gt; {

  private EntityManager entityManager;

  // There are two constructors to choose from, either can be used.
  public MyRepositoryImpl(Class&lt;T&gt; domainClass, EntityManager entityManager) {
    super(domainClass, entityManager);

    // This is the recommended method for accessing inherited class dependencies.
    this.entityManager = entityManager;
  }

  public void sharedCustomMethod(ID id) {
    // implementation goes here
  }
}</programlisting>
          </example>

          <para>The default behavior of the Spring <code>&lt;repositories
          /&gt;</code> namespace is to provide an implementation for all
          interfaces that fall under the <code>base-package</code>. This means
          that if left in its current state, an implementation instance of
          <interfacename>MyRepository</interfacename> will be created by
          Spring. This is of course not desired as it is just supposed to act
          as an intermediary between <interfacename>Repository</interfacename>
          and the actual repository interfaces you want to define for each
          entity. To exclude an interface that extends
          <interfacename>Repository</interfacename> from being instantiated as
          a repository instance, you can either annotate it with
          <interfacename>@NoRepositoryBean</interfacename> or move it outside
          of the configured <code>base-package</code>.</para>
        </listitem>

        <listitem>
          <para>Then create a custom repository factory to replace the default
          <classname>RepositoryFactoryBean</classname> that will in turn
          produce a custom <classname>RepositoryFactory</classname>. The new
          repository factory will then provide your
          <classname>MyRepositoryImpl</classname> as the implementation of any
          interfaces that extend the <interfacename>Repository</interfacename>
          interface, replacing the <classname>SimpleJpaRepository</classname>
          implementation you just extended.</para>

          <example>
            <title>Custom repository factory bean</title>

            <programlisting language="java">
public class MyRepositoryFactoryBean&lt;R extends JpaRepository&lt;T, I&gt;, T, I extends Serializable&gt;
  extends JpaRepositoryFactoryBean&lt;R, T, I&gt; {

  protected RepositoryFactorySupport createRepositoryFactory(EntityManager entityManager) {

    return new MyRepositoryFactory(entityManager);
  }

  private static class MyRepositoryFactory&lt;T, I extends Serializable&gt; extends JpaRepositoryFactory {

    private EntityManager entityManager;

    public MyRepositoryFactory(EntityManager entityManager) {
      super(entityManager);

      this.entityManager = entityManager;
    }

    protected Object getTargetRepository(RepositoryMetadata metadata) {

      return new MyRepositoryImpl&lt;T, I&gt;((Class&lt;T&gt;) metadata.getDomainClass(), entityManager);
    }

    protected Class&lt;?&gt; getRepositoryBaseClass(RepositoryMetadata metadata) {

      // The RepositoryMetadata can be safely ignored, it is used by the JpaRepositoryFactory
      //to check for QueryDslJpaRepository's which is out of scope.
      return MyRepository.class;
    }
  }
}</programlisting>
          </example>
        </listitem>

        <listitem>
          <para>Finally, either declare beans of the custom factory directly
          or use the <code>factory-class</code> attribute of the Spring
          namespace to tell the repository infrastructure to use your custom
          factory implementation.</para>

          <example>
            <title>Using the custom factory with the namespace</title>

            <programlisting language="xml">&lt;repositories base-package="com.acme.repository"
  factory-class="com.acme.MyRepositoryFactoryBean" /&gt;</programlisting>
          </example>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section>
    <title>Spring Data extensions</title>

    <para>This section documents a set of Spring Data extensions that enable
    Spring Data usage in a variety of contexts. Currently most of the
    integration is targeted towards Spring MVC.</para>

    <section id="web-domain-class-binding">
      <title>Domain class web binding for Spring MVC</title>

      <para>Given you are developing a Spring MVC web application you
      typically have to resolve domain class ids from URLs. By default your
      task is to transform that request parameter or URL part into the domain
      class to hand it to layers below then or execute business logic on the
      entities directly. This would look something like this:</para>

      <programlisting language="java">@Controller
@RequestMapping("/users")
public class UserController {

  private final UserRepository userRepository;

  @Autowired
  public UserController(UserRepository userRepository) {
    Assert.notNull(repository, "Repository must not be null!");
    userRepository = userRepository;
  }

  @RequestMapping("/{id}")
  public String showUserForm(@PathVariable("id") Long id, Model model) {
    
    // Do null check for id
    User user = userRepository.findOne(id);
    // Do null check for user

    model.addAttribute("user", user);
    return "user";
  }
}</programlisting>

      <para>First you declare a repository dependency for each controller to
      look up the entity managed by the controller or repository respectively.
      Looking up the entity is boilerplate as well, as it's always a
      <methodname>findOne(…)</methodname> call. Fortunately Spring provides
      means to register custom components that allow conversion between a
      <classname>String</classname> value to an arbitrary type.</para>

      <simplesect>
        <title>PropertyEditors</title>

        <para>For Spring versions before 3.0 simple Java
        <interfacename>PropertyEditor</interfacename>s had to be used. To
        integrate with that, Spring Data offers a
        <classname>DomainClassPropertyEditorRegistrar</classname>, which looks
        up all Spring Data repositories registered in the
        <interfacename>ApplicationContext</interfacename> and registers a
        custom <interfacename>PropertyEditor</interfacename> for the managed
        domain class.</para>

        <programlisting language="xml">&lt;bean class="….web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt;
  &lt;property name="webBindingInitializer"&gt;
    &lt;bean class="….web.bind.support.ConfigurableWebBindingInitializer"&gt;
      &lt;property name="propertyEditorRegistrars"&gt;
        &lt;bean class="org.springframework.data.repository.support.DomainClassPropertyEditorRegistrar" /&gt;
      &lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

        <para>If you have configured Spring MVC as in the preceding example,
        you can configure your controller as follows, which reduces a lot of
        the clutter and boilerplate.</para>

        <programlisting lang="" language="java">@Controller
@RequestMapping("/users")
public class UserController {

  @RequestMapping("/{id}")
  public String showUserForm(@PathVariable("id") User user, Model model) {

    model.addAttribute("user", user);
    return "userForm";
  }
}</programlisting>
      </simplesect>

      <simplesect>
        <title>ConversionService</title>

        <para>In Spring 3.0 and later the
        <interfacename>PropertyEditor</interfacename> support is superseded by
        a new conversion infrastructure that eliminates the drawbacks of
        <interfacename>PropertyEditor</interfacename>s and uses a stateless X
        to Y conversion approach. Spring Data now ships with a
        <classname>DomainClassConverter</classname> that mimics the behavior
        of <classname>DomainClassPropertyEditorRegistrar</classname>. To
        configure, simply declare a bean instance and pipe the
        <interfacename>ConversionService</interfacename> being used into its
        constructor:</para>

        <programlisting language="xml">&lt;mvc:annotation-driven conversion-service="conversionService" /&gt;

&lt;bean class="org.springframework.data.repository.support.DomainClassConverter"&gt;
  &lt;constructor-arg ref="conversionService" /&gt;
&lt;/bean&gt;</programlisting>

        <para>If you are using JavaConfig, you can simply extend Spring MVC's
        <classname>WebMvcConfigurationSupport</classname> and hand the
        <classname>FormatingConversionService</classname> that the
        configuration superclass provides into the
        <classname>DomainClassConverter</classname> instance you
        create.</para>

        <programlisting language="java">class WebConfiguration extends WebMvcConfigurationSupport {

  // Other configuration omitted

  @Bean
  public DomainClassConverter&lt;?&gt; domainClassConverter() {
    return new DomainClassConverter&lt;FormattingConversionService&gt;(mvcConversionService());
  }
}</programlisting>
      </simplesect>
    </section>

    <section id="web-pagination">
      <title>Web pagination</title>

      <para>When working with pagination in the web layer you usually have to
      write a lot of boilerplate code yourself to extract the necessary
      metadata from the request. The less desirable approach shown in the
      example below requires the method to contain an
      <interfacename>HttpServletRequest</interfacename> parameter that has to
      be parsed manually. This example also omits appropriate failure
      handling, which would make the code even more verbose.</para>

      <programlisting lang="" language="java">@Controller
@RequestMapping("/users")
public class UserController {

  // DI code omitted

  @RequestMapping
  public String showUsers(Model model, HttpServletRequest request) {

    int page = Integer.parseInt(request.getParameter("page"));
    int pageSize = Integer.parseInt(request.getParameter("pageSize"));

    Pageable pageable = new PageRequest(page, pageSize);

    model.addAttribute("users", userService.getUsers(pageable));
    return "users";
  }
}</programlisting>

      <para>The bottom line is that the controller should not have to handle
      the functionality of extracting pagination information from the request.
      So Spring Data ships with a
      <classname>PageableHandlerArgumentResolver</classname> that will do the
      work for you. The Spring MVC JavaConfig support exposes a
      <classname>WebMvcConfigurationSupport</classname> helper class to
      customize the configuration as follows:</para>

      <programlisting language="xml">@Configuration
public class WebConfig extends WebMvcConfigurationSupport {

  @Override
  public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
    converters.add(new PageableHandlerArgumentResolver());
  }
}</programlisting>

      <para>If you're stuck with XML configuration you can register the
      resolver as follows:</para>

      <programlisting language="xml">&lt;bean class="….web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;
  &lt;property name="customArgumentResolvers"&gt;
    &lt;list&gt;
      &lt;bean class="org.springframework.data.web.PageableHandlerArgumentResolver" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <para>When using Spring 3.0.x versions use the
      <classname>PageableArgumentResolver</classname> instead. Once you've
      configured the resolver with Spring MVC it allows you to simplify
      controllers down to something like this:</para>

      <programlisting lang="" language="java">@Controller
@RequestMapping("/users")
public class UserController {

  @RequestMapping
  public String showUsers(Model model, Pageable pageable) {

    model.addAttribute("users", userRepository.findAll(pageable));
    return "users";
  }
}</programlisting>

      <para>The <classname>PageableArgumentResolver</classname> automatically
      resolves request parameters to build a
      <classname>PageRequest</classname> instance. By default it expects the
      following structure for the request parameters.</para>

      <table>
        <title>Request parameters evaluated by
        <classname>PageableArgumentResolver</classname></title>

        <tgroup cols="2">
          <colspec colwidth="1*"/>

          <colspec colwidth="2*"/>

          <tbody>
            <row>
              <entry><code>page</code></entry>

              <entry>Page you want to retrieve.</entry>
            </row>

            <row>
              <entry><code>page.size</code></entry>

              <entry>Size of the page you want to retrieve.</entry>
            </row>

            <row>
              <entry><code>page.sort</code></entry>

              <entry>Property that should be sorted by.</entry>
            </row>

            <row>
              <entry><code>page.sort.dir</code></entry>

              <entry>Direction that should be used for sorting.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>In case you need multiple <interfacename>Pageable</interfacename>s
      to be resolved from the request (for multiple tables, for example) you
      can use Spring's <interfacename>@Qualifier</interfacename> annotation to
      distinguish one from another. The request parameters then have to be
      prefixed with <code>${qualifier}_</code>. So for a method signature like
      this:</para>

      <programlisting lang="" language="java">public String showUsers(Model model, 
      @Qualifier("foo") Pageable first,
      @Qualifier("bar") Pageable second) { … }</programlisting>

      <para>you have to populate <code>foo_page</code> and
      <code>bar_page</code> and the related subproperties.</para>

      <simplesect>
        <title>Configuring a global default on bean declaration</title>

        <para>The <classname>PageableArgumentResolver</classname> will use a
        <classname>PageRequest</classname> with the first page and a page size
        of 10 by default. It will use that value if it cannot resolve a
        <classname>PageRequest</classname> from the request (because of
        missing parameters, for example). You can configure a global default
        on the bean declaration directly. If you might need controller method
        specific defaults for the <interfacename>Pageable</interfacename>,
        annotate the method parameter with
        <interfacename>@PageableDefaults</interfacename> and specify page
        (through <code>pageNumber</code>), page size (through
        <code>value</code>), <code>sort</code> (list of properties to sort
        by), and <code>sortDir</code> (the direction to sort by) as annotation
        attributes:<!--BT Preceding sentence: Parameter names are different than in table above. OK? ( page.size vs. value, 
page.sort.dir vs. sortDir)

OG Yes, the sentence is actually talking about the annotation attributes as seen in the sample below. The table
above is discussing the request parameter names we are expecting by default. Simply remove comment if this makes
sense.--></para>

        <programlisting lang="" language="java">public String showUsers(Model model, 
  @PageableDefaults(pageNumber = 0, value = 30) Pageable pageable) { … }</programlisting>
      </simplesect>
    </section>

    <section>
      <title>Repository populators</title>

      <para>If you work with the Spring JDBC module, you probably are familiar
      with the support to populate a <interfacename>DataSource</interfacename>
      using SQL scripts. A similar abstraction is available on the
      repositories level, although it does not use SQL as the data definition
      language because it must be store-independent. Thus the populators
      support XML (through Spring's OXM abstraction) and JSON (through
      Jackson) to define data with which to populate the repositories.</para>

      <para>Assume you have a file <filename>data.json</filename> with the
      following content:</para>

      <example>
        <title>Data defined in JSON</title>

        <programlisting>[ { "_class" : "com.acme.Person",
 "firstname" : "Dave",
  "lastname" : "Matthews" },
  { "_class" : "com.acme.Person",
 "firstname" : "Carter",
  "lastname" : "Beauford" } ]</programlisting>
      </example>

      <para>You can easily populate your repositories by using the populator
      elements of the repository namespace provided in Spring Data Commons. To
      populate the preceding data to your
      <interfacename>PersonRepository</interfacename> , do the
      following:</para>

      <example>
        <title>Declaring a Jackson repository populator</title>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:repository="http://www.springframework.org/schema/data/repository"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/repository
    http://www.springframework.org/schema/data/repository/spring-repository.xsd"&gt;

  &lt;repository:jackson-populator location="classpath:data.json" /&gt;

&lt;/beans&gt;</programlisting>
      </example>

      <para>This declaration causes the <filename>data.json</filename> file
      being read, deserialized by a Jackson
      <classname>ObjectMapper</classname>. <!--BT Preceding, reword; wording doesn't track.

OG What exactly is not understandable. Jackson ObjectMapper is familiar to developers in the area of JSON
processing.-->The type to which the JSON object will be unmarshalled to will
      be determined by inspecting the <code>_class</code> attribute of the
      JSON document. The infrastructure will eventually select the appropriate
      repository to handle the object just deserialized.</para>

      <para>To rather use XML to define the data the repositories shall be
      populated with, you can use the <code>unmarshaller-populator</code>
      element. You configure it to use one of the XML marshaller options
      Spring OXM provides you with. See the <ulink url="???">Spring reference
      documentation</ulink> for details.</para>

      <example>
        <title>Declaring an unmarshalling repository populator (using
        JAXB)</title>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:repository="http://www.springframework.org/schema/data/repository"
  xmlns:oxm="http://www.springframework.org/schema/oxm"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/repository
    http://www.springframework.org/schema/data/repository/spring-repository.xsd
    http://www.springframework.org/schema/oxm
    http://www.springframework.org/schema/oxm/spring-oxm.xsd"&gt;

  &lt;repository:unmarshaller-populator location="classpath:data.json" unmarshaller-ref="unmarshaller" /&gt;

  &lt;oxm:jaxb2-marshaller contextPath="com.acme" /&gt;

&lt;/beans&gt;</programlisting>
      </example>
    </section>
  </section>
</chapter>
